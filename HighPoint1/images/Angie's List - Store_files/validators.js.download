define(function (require) {
  /* eslint no-var:0 */
  /* eslint no-useless-escape:0 */
  /* eslint prefer-rest-params:0 */
  var _ = require('underscore');
  var valid = require('valid');

  // options for future exensibility
  var options = {};

  // Patterns
  var patterns = {
    postalCode: /^\d{5}(-\d{4})?$/,
    // Pattern taken from passwordReset.scala.html
    password: /^[0-9A-Za-z@%'\\/!$^?:,\[\](){}~_-]{6,15}$/,
    dateISO: /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/,
    date: /^(\d{4}[-/]\d\d?[-/]\d\d?)|(\d\d?[-/]\d\d?[-/]\d{4})$/,
    textArea: /^[A-Za-z0-9\s\.,!\?;:'"()#\$%&\*@\+\/\=\^\_{|}~-]*$/,
    textAreaRelaxed: /^[A-Za-z0-9\s\.,!\?;:'"()#\$%&\*\+\/\=\^\_{|}~\[\]*-]*$/,
    phoneNumber: /^[2-9][0-9]{9}$/,
    hours: /^(0?[1-9]|1[012])(:[0-5]\d)\s[AP]M$/i,
    // A simple title: letters, numbers, or (. , ; : ' # _ -), used licenses, titles, etc
    title: /^[A-Za-z0-9\s\.,;:'#_-]*$/,

    // Same as title with the addition of allowing @, used for account holder, payee name, business name, etc
    businessName: /^[A-Za-z0-9@\s\.,!\?;:'"()#\$%&\*\+\/=\^_{|}~-]*$/,

    // Matches any digit(s) (i.e. 0-9)
    digits: /^\d+$/,

    // Matched any number (e.g. 100.000)
    number: /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/,

    // Matches a valid email address (e.g. mail@example.com)
    email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,

    // Mathes any valid url (e.g. http://www.xample.com)
    url: /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
  };

  // Error message for the build in validators.
  // {x} gets swapped out with arguments form the validator.
  var messages = {
    required: '{0} is required',
    acceptance: '{0} must be accepted',
    min: '{0} must be greater than or equal to {1}',
    max: '{0} must be less than or equal to {1}',
    range: '{0} must be between {1} and {2}',
    length: '{0} must be {1} characters',
    minLength: '{0} must be at least {1} characters',
    maxLength: '{0} cannot exceed {1} characters',
    rangeLength: '{0} must be between {1} and {2} characters',
    oneOf: '{0} must be one of: {1}',
    equalTo: '{0} must be the same as {1}',
    notEqualTo: '{0} must not be the same as {1}',
    pattern: 'Is this a valid {0}?',
    creditCard: 'Must be a valid credit card number',
    cvv: 'CVV not valid',
    hours: 'Please enter a valid time: ##:## AM or PM',
    date: 'Must be a valid date',
    phoneNumber: 'Must enter a valid 10-digit phone number',
    number: '{0} must be a valid number',
    password: 'Passwords must be between 6 and 15 characters and may include any combination of numbers, letters, and select special characters (@%/\'!$^?:,(){}[]~-_)',
    textArea: 'Please use only the following characters: letters, numbers and . , ! ? ; : \' " ( ) # @ $ % & * + - / = ^ _ { | } ~',
    textAreaRelaxed: 'Please use only the following characters: letters, numbers and . , ! ? ; : \' \" ( ) # $ % & * + - / = ^ _ { | } ~ [ ] *',
    title: 'Please use only the following characters: letters, numbers and . , ; : \' # _ -',
    businessName: 'Please use only the following characters: letters, numbers and . , ! ? ; : \' " ( ) # $ @ % & * + - / = ^ _ { | } ~'
  };

  // Label formatters are used to convert the attribute name to a more human friendly label when using the built in error messages.
  var labelFormatters = {
    // Returns the attribute name with applying any formatting
    none: function (attrName) {
      return attrName;
    },

    // Converts attributeName or attribute_name to Attribute name
    sentenceCase: function (attrName) {
      // If attrName contains a '.' get only text aftr the last '.'
      // Ex: 'User.firstName' => 'First name'
      var name = (attrName.indexOf('.') > -1) ? attrName.split('.').pop() : attrName;

      return name.replace(/(?:^\w|[A-Z]|\b\w)/g, function (match, index) {
        return index === 0 ? match.toUpperCase() : ' ' + match.toLowerCase();
      }).replace('_', ' ');
    }
  };

  var trim = function (text) {
    return text === null ? '' : text.toString().replace(/^\s+|\s+$/g, '');
  };

  // Determines whether or not a value is a number
  var isNumber = function (value) {
    return _.isNumber(value) || (_.isString(value) && value.match(patterns.number));
  };

  // Determines whether or not not a value is empty
  var hasValue = function (value) {
    return !(_.isNull(value) || _.isUndefined(value) || (_.isString(value) && trim(value) === '') || (_.isArray(value) && _.isEmpty(value)));
  };

  // Uses the configured label formatter to format the attribute name
  // to make it more readable for the user
  var formatLabel = function (attrName, data) {
    return labelFormatters[(options || {}).labelFormatter || 'sentenceCase'](attrName, data);
  };

  // TODO: This can move to a utility library like a lodash mixin
  // Replaces numeric placeholders like {0} in a string with arguments passed to the function
  var format = function (/* text, ... multiple arguments */) {
    var args = [].slice.call(arguments);
    var text = args.shift(); // first argument is the "text", the rest are formatting args

    return text.replace(/\{(\d+)\}/g, function (match, number) {
      return !_.isUndefined(args[number]) ? args[number] : match;
    });
  };

  var validators = {
    // Function validator
    // Lets you implement a custom function used for validation
    fn: function (value, attr, fn, model) {
      var func = fn;
      if (_.isString(func)) {
        func = model[func];
      }
      return func.call(model, value, attr);
    },

    // Required validator
    // Validates if the attribute is required or not
    required: function (value, attr, required, model) {
      var isRequired = _.isFunction(required) ? required.call(model, value, attr) : required;
      if (!isRequired && !hasValue(value)) {
        return false; // overrides all other validators
      }
      if (isRequired && !hasValue(value)) {
        return format(messages.required, formatLabel(attr, model));
      }

      return undefined;
    },

    // Acceptance validator
    // Validates that something has to be accepted, e.g. terms of use
    // `true` or 'true' are valid
    acceptance: function (value, attr, accept, model) {
      if (!accept) {
        return undefined;
      }

      if (value !== 'true' && (!_.isBoolean(value) || value === false)) {
        return format(messages.acceptance, formatLabel(attr, model));
      }

      return undefined;
    },

    // Min validator
    // Validates that the value has to be a number and equal to or greater than
    // the min value specified
    min: function (value, attr, minValue, model) {
      if (!isNumber(value) || value < minValue) {
        return format(messages.min, formatLabel(attr, model), minValue);
      }

      return undefined;
    },

    // Max validator
    // Validates that the value has to be a number and equal to or less than
    // the max value specified
    max: function (value, attr, maxValue, model) {
      if (!isNumber(value) || value > maxValue) {
        return format(messages.max, formatLabel(attr, model), maxValue);
      }

      return undefined;
    },

    // Range validator
    // Validates that the value has to be a number and equal to or between
    // the two numbers specified
    range: function (value, attr, range, model) {
      if (!isNumber(value) || value < range[0] || value > range[1]) {
        return format(messages.range, formatLabel(attr, model), range[0], range[1]);
      }

      return undefined;
    },

    // Length validator
    // Validates that the value has to be a string with length equal to
    // the length value specified
    length: function (value, attr, length, model) {
      if (!hasValue(value) || trim(value).length !== length) {
        return format(messages.length, formatLabel(attr, model), length);
      }

      return undefined;
    },

    // Min length validator
    // Validates that the value has to be a string with length equal to or greater than
    // the min length value specified
    minLength: function (value, attr, minLength, model) {
      if (!hasValue(value) || trim(value).length < minLength) {
        return format(messages.minLength, formatLabel(attr, model), minLength);
      }

      return undefined;
    },

    // Max length validator
    // Validates that the value has to be a string with length equal to or less than
    // the max length value specified
    maxLength: function (value, attr, maxLength, model) {
      if (!hasValue(value) || trim(value).length > maxLength) {
        return format(messages.maxLength, formatLabel(attr, model), maxLength);
      }

      return undefined;
    },

    // Range length validator
    // Validates that the value has to be a string and equal to or between
    // the two numbers specified
    rangeLength: function (value, attr, range, model) {
      if (!hasValue(value) || trim(value).length < range[0] || trim(value).length > range[1]) {
        return format(messages.rangeLength, formatLabel(attr, model), range[0], range[1]);
      }

      return undefined;
    },

    // One of validator
    // Validates that the value has to be equal to one of the elements in
    // the specified array. Case sensitive matching
    oneOf: function (value, attr, values, model) {
      if (!_.include(values, value)) {
        return format(messages.oneOf, formatLabel(attr, model), values.join(', '));
      }

      return undefined;
    },

    // Equal to validator
    // Validates that the value has to be equal to the value of the attribute
    // with the name specified
    equalTo: function (value, attr, equalTo, model) {
      if (value !== _.get(model, equalTo)) {
        return format(messages.equalTo, formatLabel(attr, model), formatLabel(equalTo, model));
      }

      return undefined;
    },

    // Not equal to validator
    // Validates that the value has to be different than the value of the attribute
    // with the name specified
    notEqualTo: function (value, attr, notEqualTo, model) {
      if (value === _.get(model, notEqualTo)) {
        return format(messages.notEqualTo, formatLabel(attr, model), formatLabel(notEqualTo, model));
      }

      return undefined;
    },

    // Pattern validator
    // Validates that the value has to match the pattern specified.
    // Can be a regular expression or the name of one of the built in patterns
    pattern: function (value, attr, pattern, model) {
      if (!hasValue(value) || !value.toString().match(patterns[pattern] || pattern)) {
        return format(messages.pattern, formatLabel(attr, model), pattern);
      }

      return undefined;
    },

    date: function (value, attr, customValue, model) {
      if (!customValue || !value) {
        return undefined;
      }
      var isValid = patterns.date.test(value);
      if (!isValid) {
        return format(messages.date, formatLabel(attr, model));
      }

      return undefined;
    },
    textArea: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.textArea.test(value);
      if (!isValid) {
        return format(messages.textArea, formatLabel(attr, model));
      }

      return undefined;
    },
    textAreaRelaxed: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.textAreaRelaxed.test(value);
      if (!isValid) {
        return format(messages.textAreaRelaxed, formatLabel(attr, model));
      }

      return undefined;
    },
    password: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.password.test(value);
      if (!isValid) {
        return format(messages.password, formatLabel(attr, model));
      }

      return undefined;
    },
    number: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.number.test(value);
      if (!isValid) {
        return format(messages.number, formatLabel(attr, model));
      }

      return undefined;
    },
    phoneNumber: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.phoneNumber.test(value);
      if (!isValid) {
        return format(messages.phoneNumber, formatLabel(attr, model));
      }

      return undefined;
    },
    title: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.title.test(value);
      if (!isValid) {
        return format(messages.title, formatLabel(attr, model));
      }

      return undefined;
    },
    businessName: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.businessName.test(value);
      if (!isValid) {
        return format(messages.businessName, formatLabel(attr, model));
      }

      return undefined;
    },
    creditCard: function (value, attr, customValue, model) {
      if (!customValue || !value) {
        return undefined;
      }
      if ((value && 0) <= value.length && !valid.creditcard(value)) {
        return format(messages.creditCard, formatLabel(attr, model));
      }

      return undefined;
    },
    cvv: function (value, attr, customValue, model) {
      if (!customValue || !value) {
        return undefined;
      }
      if ((value && 0) <= value.length && !valid.cvv(value)) {
        return format(messages.cvv, formatLabel(attr, model));
      }

      return undefined;
    },
    validateHours: function (value, attr, customValue, model) {
      if (!customValue) {
        return undefined;
      }
      var isValid = patterns.hours.test(value);
      if (!isValid) {
        return format(messages.hours, formatLabel(attr, model));
      }

      return undefined;
    }
  };

  return {
    validators: validators,
    patterns: patterns,
    messages: messages
  };
});
