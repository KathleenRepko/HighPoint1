// Documentation for Validation can be found at:
// https://angieslist.atlassian.net/wiki/display/SE/Data+Validation
define(function (require) {
  /* eslint no-var:0 */
  var _ = require('underscore');
  var validators = require('validators');

  // Default options
  var defaultOptions = {
    selector: 'name',
    labelFormatter: 'sentenceCase'
  };

  /* eslint "max-params": 0 */ // This is an internal method and acceptable
  var processRule = function (value, myValidators, rule, result, attr, data) {
    _.forOwn(rule, function (v, key) {
      if (myValidators[key]) {
        var msg = myValidators[key](value, attr, v, data);

        if (msg === false) {
          return false;
        }

        if (msg) {
          // if we have an error msg but an overwritten msg is on
          // the rule, use that, else use the error msg
          /* eslint no-param-reassign: 0 */ // We are mutating the object
          result.invalidAttrs[attr] = (rule.msg) ? rule.msg : msg;
          result.isValid = false;
          return false;
        }
      }
      return undefined;
    });
  };

  var getRule = function (rules, ruleName) {
    var result;
    if (_.isArray(rules)) {
      _.forEach(rules, function (subRule) {
        if (!_.isUndefined(subRule[ruleName])) {
          result = subRule[ruleName];
        }
      });
    }
    return result || (rules || {})[ruleName];
  };

  var validation = {
    // determine if a field is required based on validation rules
    isRequired: function (attrName, rules) {
      return getRule(rules[attrName], 'required') || false;
    },

    getMaxLength: function (attrName, rules) {
      var maxLength = getRule(rules[attrName], 'maxLength');
      var rangeLength = getRule(rules[attrName], 'rangeLength');
      return maxLength || (rangeLength ? rangeLength[1] : undefined) || undefined;
    },

    validate: function (data, rules, options) {
      var result = {
        isValid: true,
        invalidAttrs: {}
      };
      // options for future exensibility
      var opts = _.defaults(options || {}, defaultOptions);

      // Determine if validation rules are applied and process them
      if (rules) {
        var self = this;

        // for each defined rule set
        _.forOwn(rules, function (value, attr) {
          var attrValue = _.get(data, attr);
          if (_.isFunction(rules[attr])) {
            // if the value is a function, then execute it to get the message
            var msg = rules[attr](attrValue);
            if (msg) {
              result.invalidAttrs[attr] = msg;
              result.isValid = false;
            }
          } else if (_.isArray(rules[attr])) {
            // if the value is an array, then assume it to have objects with rules and messages
            _.forEach(rules[attr], function (rule) {
              processRule(attrValue, self.validators, rule, result, attr, data);
            });
          } else if (_.isObject(rules[attr])) {
            // else for each validator on that field
            processRule(attrValue, self.validators, rules[attr], result, attr, data);
          }
        });
      }

      return result;
    }
  };

  // attach the validators to the validation object
  _.extend(validation, validators);

  return validation;
});
